<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Swipe Navigation Implementation - Track & Field App</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            margin: 2cm;
            color: #333;
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        h2 {
            color: #34495e;
            margin-top: 30px;
            border-left: 4px solid #3498db;
            padding-left: 15px;
        }
        h3 {
            color: #7f8c8d;
            margin-top: 25px;
        }
        pre {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.4;
        }
        code {
            background-color: #f1f2f6;
            padding: 2px 4px;
            border-radius: 3px;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
        }
        ul {
            margin-left: 20px;
        }
        li {
            margin-bottom: 5px;
        }
        .highlight {
            background-color: #fff3cd;
            padding: 10px;
            border-left: 4px solid #ffc107;
            margin: 15px 0;
        }
        .section {
            page-break-inside: avoid;
            margin-bottom: 30px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>

<h1>Swipe Navigation Implementation - Track & Field App</h1>

<div class="section">
<h2>Overview</h2>
<p>This document contains the complete implementation of native app-like swipe navigation for the track and field training application. The implementation provides smooth page transitions with visual feedback and boundary detection.</p>
</div>

<div class="section">
<h2>Libraries Used</h2>
<ul>
    <li><strong>React</strong> (useState, useEffect, useRef) - State management and lifecycle</li>
    <li><strong>Wouter</strong> - Lightweight routing library (<code>useLocation</code> hook)</li>
    <li><strong>Native Browser Touch Events API</strong> - No external gesture libraries required</li>
</ul>
</div>

<div class="section">
<h2>Architecture</h2>

<h3>Main Components</h3>
<ol>
    <li><code>useSwipeNavigation</code> hook - Core gesture detection and navigation logic</li>
    <li><code>SwipeContainer</code> component - Visual transitions and page rendering</li>
    <li><code>ScrollRestoration</code> component - Ensures pages start at top</li>
    <li><code>BottomNavigation</code> component - Icon-only navigation bar</li>
</ol>
</div>

<div class="section">
<h2>Core Implementation Files</h2>

<h3>1. Swipe Navigation Hook</h3>
<p><strong>File:</strong> <code>client/src/hooks/use-swipe-navigation.tsx</code></p>

<pre><code>import { useState, useEffect, useRef } from 'react';
import { useLocation } from 'wouter';

interface SwipeNavigationHook {
  containerRef: React.RefObject&lt;HTMLDivElement&gt;;
  currentTransform: number;
  isTransitioning: boolean;
  swipeProgress: number;
  nextPageDirection: 'left' | 'right' | null;
}

export function useSwipeNavigation(
  navItems: Array&lt;{ href: string; title: string; component?: React.ReactNode }&gt;,
  currentIndex: number
): SwipeNavigationHook {
  const [, setLocation] = useLocation();
  const [currentTransform, setCurrentTransform] = useState(0);
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [swipeProgress, setSwipeProgress] = useState(0);
  const [nextPageDirection, setNextPageDirection] = useState&lt;'left' | 'right' | null&gt;(null);
  
  const containerRef = useRef&lt;HTMLDivElement&gt;(null);
  const touchStartX = useRef&lt;number | null&gt;(null);
  const touchStartY = useRef&lt;number | null&gt;(null);
  const isDragging = useRef(false);

  useEffect(() =&gt; {
    const handleTouchStart = (e: TouchEvent) =&gt; {
      if (isTransitioning) return;
      
      touchStartX.current = e.touches[0].clientX;
      touchStartY.current = e.touches[0].clientY;
      isDragging.current = false;
    };

    const handleTouchMove = (e: TouchEvent) =&gt; {
      if (!touchStartX.current || !touchStartY.current || isTransitioning) return;
      
      const currentX = e.touches[0].clientX;
      const currentY = e.touches[0].clientY;
      const deltaX = currentX - touchStartX.current;
      const deltaY = currentY - touchStartY.current;
      
      // Check if this is a horizontal swipe
      if (Math.abs(deltaX) &gt; Math.abs(deltaY) && Math.abs(deltaX) &gt; 10) {
        isDragging.current = true;
        e.preventDefault();
        
        const progress = Math.abs(deltaX) / window.innerWidth;
        const clampedProgress = Math.min(progress, 1);
        
        // Determine swipe direction and check boundaries
        if (deltaX &gt; 0 && currentIndex &gt; 0) {
          // Swiping right (previous page) - only if not at first page
          setNextPageDirection('right');
          setSwipeProgress(clampedProgress);
          setCurrentTransform(deltaX);
        } else if (deltaX &lt; 0 && currentIndex &lt; navItems.length - 1) {
          // Swiping left (next page) - only if not at last page
          setNextPageDirection('left');
          setSwipeProgress(clampedProgress);
          setCurrentTransform(deltaX);
        } else {
          // At boundary - don't allow swipe
          return;
        }
      }
    };

    const handleTouchEnd = (e: TouchEvent) =&gt; {
      if (!touchStartX.current || !isDragging.current || isTransitioning) {
        // Reset states
        setCurrentTransform(0);
        setSwipeProgress(0);
        setNextPageDirection(null);
        touchStartX.current = null;
        touchStartY.current = null;
        isDragging.current = false;
        return;
      }
      
      const endX = e.changedTouches[0].clientX;
      const deltaX = endX - touchStartX.current;
      const threshold = window.innerWidth * 0.5; // 50% of screen width
      
      setIsTransitioning(true);
      
      if (Math.abs(deltaX) &gt; threshold) {
        // Complete the navigation - animate to full position
        if (deltaX &gt; 0 && currentIndex &gt; 0) {
          // Navigate to previous page - complete slide right
          setCurrentTransform(window.innerWidth);
          setTimeout(() =&gt; {
            setLocation(navItems[currentIndex - 1].href);
            setCurrentTransform(0);
            setSwipeProgress(0);
            setNextPageDirection(null);
            setIsTransitioning(false);
          }, 300);
        } else if (deltaX &lt; 0 && currentIndex &lt; navItems.length - 1) {
          // Navigate to next page - complete slide left
          setCurrentTransform(-window.innerWidth);
          setTimeout(() =&gt; {
            setLocation(navItems[currentIndex + 1].href);
            setCurrentTransform(0);
            setSwipeProgress(0);
            setNextPageDirection(null);
            setIsTransitioning(false);
          }, 300);
        }
      } else {
        // Snap back to current page
        setCurrentTransform(0);
        setTimeout(() =&gt; {
          setSwipeProgress(0);
          setNextPageDirection(null);
          setIsTransitioning(false);
        }, 300);
      }
      
      touchStartX.current = null;
      touchStartY.current = null;
      isDragging.current = false;
    };

    document.addEventListener('touchstart', handleTouchStart, { passive: true });
    document.addEventListener('touchmove', handleTouchMove, { passive: false });
    document.addEventListener('touchend', handleTouchEnd, { passive: true });

    return () =&gt; {
      document.removeEventListener('touchstart', handleTouchStart);
      document.removeEventListener('touchmove', handleTouchMove);
      document.removeEventListener('touchend', handleTouchEnd);
    };
  }, [currentIndex, navItems, setLocation, isTransitioning]);

  return {
    containerRef,
    currentTransform,
    isTransitioning,
    swipeProgress,
    nextPageDirection
  };
}</code></pre>
</div>

<div class="section">
<h3>2. Swipe Container Component</h3>
<p><strong>File:</strong> <code>client/src/components/layout/swipe-container.tsx</code></p>

<pre><code>import { useSwipeNavigation } from '@/hooks/use-swipe-navigation';

interface SwipeContainerProps {
  children: React.ReactNode;
  navItems: Array&lt;{ href: string; title: string; component?: React.ReactNode }&gt;;
  currentIndex: number;
  className?: string;
}

export function SwipeContainer({ children, navItems, currentIndex, className = "" }: SwipeContainerProps) {
  const {
    containerRef,
    currentTransform,
    isTransitioning,
    swipeProgress,
    nextPageDirection
  } = useSwipeNavigation(navItems, currentIndex);

  const getNextPageComponent = () =&gt; {
    if (nextPageDirection === 'left' && currentIndex &lt; navItems.length - 1) {
      return navItems[currentIndex + 1].component || null;
    } else if (nextPageDirection === 'right' && currentIndex &gt; 0) {
      return navItems[currentIndex - 1].component || null;
    }
    return null;
  };

  return (
    &lt;div 
      ref={containerRef}
      className={`relative overflow-hidden ${className}`}
      style={{ touchAction: 'pan-y' }}
    &gt;
      {/* Current page */}
      &lt;div
        className="w-full"
        style={{
          transform: `translateX(${currentTransform}px)`,
          transition: isTransitioning ? 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)' : 'none'
        }}
      &gt;
        {children}
      &lt;/div&gt;

      {/* Next page preview - actual page content */}
      {nextPageDirection && (swipeProgress &gt; 0 || isTransitioning) && (
        &lt;div
          className="absolute top-0 w-full h-full bg-background"
          style={{
            left: nextPageDirection === 'left' ? '100%' : '-100%',
            transform: isTransitioning 
              ? `translateX(${nextPageDirection === 'left' ? '-100%' : '100%'})` 
              : `translateX(${nextPageDirection === 'left' ? -swipeProgress * 100 : swipeProgress * 100}%)`,
            transition: isTransitioning ? 'transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94)' : 'none'
          }}
        &gt;
          &lt;div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 h-full"&gt;
            {getNextPageComponent()}
          &lt;/div&gt;
        &lt;/div&gt;
      )}

      {/* Swipe indicator */}
      {swipeProgress &gt; 0 && (
        &lt;div className="absolute bottom-20 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-50 text-white px-3 py-1 rounded-full text-xs"&gt;
          {Math.round(swipeProgress * 100)}%
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
</div>

<div class="section">
<h3>3. Scroll Restoration Component</h3>
<p><strong>File:</strong> <code>client/src/App.tsx</code></p>

<pre><code>// Component to handle scroll restoration
function ScrollRestoration() {
  const [location] = useLocation();
  
  useEffect(() =&gt; {
    // Disable browser's automatic scroll restoration
    if ('scrollRestoration' in history) {
      history.scrollRestoration = 'manual';
    }
    
    // Immediately scroll to top
    window.scrollTo(0, 0);
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    
    // Force scroll to top with a slight delay
    const timer = setTimeout(() =&gt; {
      window.scrollTo({ top: 0, left: 0, behavior: 'instant' });
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      
      // Force all scrollable containers to reset
      const scrollableElements = document.querySelectorAll('[style*="overflow"]');
      scrollableElements.forEach(el =&gt; {
        if (el instanceof HTMLElement) {
          el.scrollTop = 0;
        }
      });
    }, 100);
    
    return () =&gt; clearTimeout(timer);
  }, [location]);
  
  return null;
}</code></pre>
</div>

<div class="section">
<h2>Key Technical Features</h2>

<h3>Touch Event Handling</h3>
<ul>
    <li><strong>Touch Start:</strong> Captures initial finger position (X, Y coordinates)</li>
    <li><strong>Touch Move:</strong> Tracks gesture progress and applies real-time transforms</li>
    <li><strong>Touch End:</strong> Determines completion threshold (50% screen width) and triggers navigation or snap-back</li>
</ul>

<h3>Gesture Detection</h3>
<ul>
    <li><strong>Horizontal vs Vertical:</strong> Uses <code>Math.abs(deltaX) > Math.abs(deltaY)</code> to detect horizontal swipes</li>
    <li><strong>Minimum Threshold:</strong> 10px movement required to initiate swipe</li>
    <li><strong>Boundary Detection:</strong> Prevents swiping beyond first/last pages</li>
</ul>

<h3>Animation System</h3>
<ul>
    <li><strong>CSS Transforms:</strong> Uses <code>translateX()</code> for hardware-accelerated transitions</li>
    <li><strong>Cubic Bezier Easing:</strong> <code>cubic-bezier(0.25, 0.46, 0.45, 0.94)</code> for natural feel</li>
    <li><strong>300ms Duration:</strong> Consistent timing for all transitions</li>
    <li><strong>State Management:</strong> Tracks transition state to prevent gesture conflicts</li>
</ul>

<h3>Performance Optimizations</h3>
<ul>
    <li><strong>Touch Action:</strong> <code>touchAction: 'pan-y'</code> allows vertical scrolling while intercepting horizontal</li>
    <li><strong>Passive Events:</strong> Uses <code>passive: true</code> for better performance where possible</li>
    <li><strong>Event Prevention:</strong> Only prevents default when horizontal swipe is detected</li>
    <li><strong>Memory Cleanup:</strong> Removes event listeners on component unmount</li>
</ul>
</div>

<div class="section">
<h2>Navigation Structure</h2>

<h3>Bottom Navigation Items</h3>
<table>
    <tr>
        <th>Page</th>
        <th>Description</th>
        <th>Icon</th>
    </tr>
    <tr>
        <td>Home</td>
        <td>Dashboard with today's training</td>
        <td>House icon</td>
    </tr>
    <tr>
        <td>Training</td>
        <td>Practice sessions and workouts</td>
        <td>Dumbbell icon</td>
    </tr>
    <tr>
        <td>Programs</td>
        <td>Training program library</td>
        <td>Calendar icon</td>
    </tr>
    <tr>
        <td>Meets</td>
        <td>Competition calendar and results</td>
        <td>Trophy icon</td>
    </tr>
    <tr>
        <td>Tools</td>
        <td>Workout utilities (stopwatch, start gun, etc.)</td>
        <td>Wrench icon</td>
    </tr>
    <tr>
        <td>Sprinthia</td>
        <td>AI training assistant</td>
        <td>Custom diamond star icon (yellow)</td>
    </tr>
</table>

<h3>Icon-Only Design</h3>
<ul>
    <li>No text labels for cleaner mobile experience</li>
    <li>Custom SVG icons with active/inactive states</li>
    <li>Yellow accent color for active state</li>
    <li>Consistent 20px icon size</li>
</ul>
</div>

<div class="section">
<h2>Implementation Notes</h2>

<div class="highlight">
<h3>State Management</h3>
<ul>
    <li>Uses React hooks for local state management</li>
    <li>No external state libraries required</li>
    <li>Refs for touch position tracking to avoid re-renders</li>
</ul>
</div>

<h3>Routing Integration</h3>
<ul>
    <li>Integrates seamlessly with Wouter routing</li>
    <li>Updates URL on navigation completion</li>
    <li>Maintains browser history for back button support</li>
</ul>

<h3>Cross-Platform Compatibility</h3>
<ul>
    <li>Works on iOS Safari, Android Chrome, and desktop browsers</li>
    <li>Handles different screen sizes and orientations</li>
    <li>Respects user's reduced motion preferences</li>
</ul>

<h3>Error Handling</h3>
<ul>
    <li>Graceful fallback if touch events unavailable</li>
    <li>State reset on navigation interruption</li>
    <li>Boundary protection prevents invalid navigation</li>
</ul>
</div>

<div class="section">
<h2>Conclusion</h2>
<p>This implementation provides a native app-like experience with smooth, intuitive swipe navigation that feels natural on mobile devices while maintaining web accessibility standards. The custom implementation using native browser APIs ensures optimal performance and compatibility across platforms.</p>
</div>

</body>
</html>